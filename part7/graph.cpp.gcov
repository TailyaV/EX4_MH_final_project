        -:    0:Source:graph.cpp
        -:    0:Graph:graph.gcno
        -:    0:Data:graph.gcda
        -:    0:Runs:1
        -:    1:#include "graph.hpp"           
        -:    2:#include <iostream>       
        -:    3:#include <algorithm>   
        -:    4:#include <stack>
        -:    5:#include <queue>
        -:    6:#include <limits.h>
        -:    7:
        -:    8:// Constructor for the Graph class
        1:    9:Graph::Graph(int vertices, bool directed) 
        1:   10:    : numVertices(vertices),  
        1:   11:      directed(directed),        
        1:   12:      adjList(vertices) {}       
        -:   13:
        -:   14:// Function to add an edge between two vertices u and v
        9:   15:void Graph::addEdge(int u, int v) {
        9:   16:    if (u < 0 || u >= numVertices || v < 0 || v >= numVertices) {  // Check if u and v are valid indices
        1:   17:        std::cout << "Error: Invalid vertex index." << std::endl;  // Print error if they are out of range
        1:   18:        return;                                                   
        -:   19:    }
        8:   20:    adjList[u].push_back(v); // Add v to u's adjacency list
        8:   21:    if (!directed) { // If the graph is undirected
        8:   22:        adjList[v].push_back(u);// Add u to v's adjacency list as well
        -:   23:    }
        -:   24:}
        -:   25:
        -:   26:// Function to remove an edge between two vertices u and v
        2:   27:void Graph::removeEdge(int u, int v) {
        2:   28:    if (u < 0 || u >= numVertices || v < 0 || v >= numVertices) {  // Check if u and v are valid indices
        1:   29:        std::cout << "Error: Invalid vertex index." << std::endl;  
        1:   30:        return;                                                
        -:   31:    }
        1:   32:    auto& neighborsU = adjList[u]; // Reference to u's adjacency list
        2:   33:    neighborsU.erase(                                              
        1:   34:        std::remove(neighborsU.begin(), neighborsU.end(), v), // Find v in u's list and move it to the end
        1:   35:        neighborsU.end() // Erase the found element(s)
        -:   36:    );
        1:   37:    if (!directed) {  // If the graph is undirected
        1:   38:        auto& neighborsV = adjList[v]; // Reference to v's adjacency list
        2:   39:        neighborsV.erase(                                          
        1:   40:            std::remove(neighborsV.begin(), neighborsV.end(), u),  // Find u in v's list and move it to the end
        2:   41:            neighborsV.end() // Erase the found element(s)
        -:   42:        );
        -:   43:    }
        -:   44:}
        -:   45:
        -:   46:// Function to print the adjacency list of the graph
        1:   47:void Graph::printGraph() const {
        6:   48:    for (int i = 0; i < numVertices; i++) {       
        5:   49:        std::cout << i << ": "; // Print the current vertex index
       21:   50:        for (int neighbor : adjList[i]) {         
       16:   51:            std::cout << neighbor << " "; // Print each neighbor
        -:   52:        }
        5:   53:        std::cout << std::endl; // Move to a new line after printing all neighbors
        -:   54:    }
        1:   55:}
        -:   56:
        -:   57:// Function to get the list of neighbors for vertex v
        1:   58:const std::vector<int>& Graph::getNeighbors(int v) const {
        1:   59:    return adjList[v];         
        -:   60:}
        -:   61:
        -:   62:// Function to get the total number of vertices in the graph
        2:   63:int Graph::getNumVertices() const {
        2:   64:    return numVertices;                        
        -:   65:}
        -:   66:
        -:   67:// Depth-First Search helper function to mark all reachable vertices
       10:   68:void Graph::dfs(int v, vector<bool>& visited, const vector<vector<int>>& localAdjList) const {
       10:   69:    visited[v] = true; // Mark the current vertex as visited
        -:   70:
        -:   71:    // Loop over all neighbors of vertex v
       38:   72:    for (int neighbor : localAdjList[v]) {
        -:   73:        // If the neighbor hasn't been visited yet, visit it recursively
       28:   74:        if (!visited[neighbor]) {
        8:   75:            dfs(neighbor, visited, localAdjList);
        -:   76:        }
        -:   77:    }
       10:   78:}
        -:   79:
        -:   80:// Checks whether the graph contains an Euler circuit
        2:   81:bool Graph::hasEulerCircuit() const {
        2:   82:    vector<bool> visited(numVertices, false);// Create a visited array initialized to false
        2:   83:    int start = -1;
        -:   84:
        -:   85:    // Find a vertex with at least one edge to start the DFS from
       2*:   86:    for (int i = 0; i < numVertices; ++i) {
        2:   87:        if (!adjList[i].empty()) { // This vertex has neighbors
        2:   88:            start = i;
        2:   89:            break;
        -:   90:        }
        -:   91:    }
        -:   92:    // If no vertex has any edges, the graph is empty (no edges), which is a trivial Euler circuit
       2*:   93:    if (start == -1) return true; // No edges
        -:   94:
        -:   95:    // Perform DFS to check if all non-isolated vertices are reachable (i.e., graph is connected)
        2:   96:    dfs(start, visited, adjList);
        -:   97:
        -:   98:    // Ensure all vertices that have edges are visited
       12:   99:    for (int i = 0; i < numVertices; ++i) {
      10*:  100:        if (!adjList[i].empty() && !visited[i]) return false;// Graph is not connected
        -:  101:    }
        -:  102:
        -:  103:    // Check that all vertices have even degree
       2*:  104:    for (const auto& neighbors : adjList) {
        2:  105:        if (neighbors.size() % 2 != 0) return false;// Vertex has odd degree =no Euler circuit
        -:  106:
        -:  107:    }
    -   -:  108:    return true;
        2:  109:}
        -:  110:
        -:  111:// Finds and returns an Euler circuit starting from the given vertex
        1:  112:vector<int> Graph::findEulerCircuit(int start) {
        1:  113:    vector<int> circuit;
        -:  114:
        -:  115:    // If the graph does not have an Euler circuit, return an empty vector
        1:  116:    if (!hasEulerCircuit()) return circuit;
        -:  117:
        -:  118:    vector<vector<int>> tempAdj = adjList;// Make a temporary copy of the adjacency list to modify
        -:  119:    stack<int> path;// Stack to track the current path in the traversal
        -:  120:    vector<int> result;// To store the final Euler circuit in reverse
        -:  121:
        -:  122:    path.push(start);// Begin traversal at the starting vertex
        -:  123:
        -:  124:    while (!path.empty()) {
        -:  125:        int v = path.top();// Look at the current vertex on top of the stack
        -:  126:        if (!tempAdj[v].empty()) {
        -:  127:            // While there are unused edges from v, go deeper
        -:  128:            int u = tempAdj[v].back();// Choose the last neighbor
        -:  129:            tempAdj[v].pop_back(); // Remove edge vu from v’s list
        -:  130:            if (!directed) {
        -:  131:                // For undirected graph, also remove the edge u → v from u's list
        -:  132:                auto& vec = tempAdj[u];
        -:  133:                vec.erase(remove(vec.begin(), vec.end(), v), vec.end());
        -:  134:            }
        -:  135:            path.push(u);// Continue to the neighbor u
        -:  136:        } else {
        -:  137:            // No more edges left from v → backtrack
        -:  138:            result.push_back(v);// Add v to the result
        -:  139:            path.pop();// Go back to previous vertex
        -:  140:        }
        -:  141:    }
        -:  142:    reverse(result.begin(), result.end());// Reverse the result to get correct path order
        -:  143:    return result;// Return the final Euler circuit
       1*:  144:}
        -:  145:
        -:  146:
        -:  147:
        -:  148:
        -:  149:// ---------- Minimum Spanning Tree (Prim's) ----------
        1:  150:int Graph::mstWeight() const {
       1*:  151:    if (directed) return -1; // MST is for undirected graphs only
        1:  152:    int totalWeight = 0;
        1:  153:    std::vector<bool> visited(numVertices, false);
        1:  154:    std::vector<int> minEdge(numVertices, INT_MAX);
        1:  155:    minEdge[0] = 0;
        -:  156:
        6:  157:    for (int i = 0; i < numVertices; ++i) {
        5:  158:        int u = -1;
       30:  159:        for (int v = 0; v < numVertices; ++v) {
       25:  160:            if (!visited[v] && (u == -1 || minEdge[v] < minEdge[u])) {
        6:  161:                u = v;
        -:  162:            }
        -:  163:        }
        -:  164:
        5:  165:        visited[u] = true;
        5:  166:        totalWeight += minEdge[u];
        -:  167:
       19:  168:        for (int neighbor : adjList[u]) {
       14:  169:            if (!visited[neighbor]) {
        7:  170:                minEdge[neighbor] = std::min(minEdge[neighbor], 1); // Weight is 1
        -:  171:            }
        -:  172:        }
        -:  173:    }
        1:  174:    return totalWeight;
        1:  175:}
        -:  176:
        -:  177:// ---------- Counting Cliques (brute force) ----------
       31:  178:bool isClique(const std::vector<int>& subset, const std::vector<std::vector<int>>& adj) {
       59:  179:    for (size_t i = 0; i < subset.size(); ++i) {
       69:  180:        for (size_t j = i + 1; j < subset.size(); ++j) {
       41:  181:            int u = subset[i], v = subset[j];
       41:  182:            if (std::find(adj[u].begin(), adj[u].end(), v) == adj[u].end())
       17:  183:                return false;
        -:  184:        }
        -:  185:    }
       14:  186:    return true;
        -:  187:}
        -:  188:
        1:  189:int Graph::countCliques() {
        1:  190:    int count = 0;
        1:  191:    int n = numVertices;
       32:  192:    for (int mask = 1; mask < (1 << n); ++mask) {
       31:  193:        std::vector<int> subset;
      186:  194:        for (int i = 0; i < n; ++i)
      155:  195:            if (mask & (1 << i))
       80:  196:                subset.push_back(i);
       31:  197:        if (isClique(subset, adjList)) count++;
       31:  198:    }
        1:  199:    return count;
        -:  200:}
        -:  201:
        -:  202:// ---------- Strongly Connected Components (Kosaraju) ----------
        5:  203:void dfs1(int v, std::vector<bool>& visited, std::stack<int>& order, const std::vector<std::vector<int>>& adj) {
        5:  204:    visited[v] = true;
       19:  205:    for (int u : adj[v])
       14:  206:        if (!visited[u]) dfs1(u, visited, order, adj);
        5:  207:    order.push(v);
        5:  208:}
        -:  209:
        5:  210:void dfs2(int v, std::vector<bool>& visited, std::vector<int>& component, const std::vector<std::vector<int>>& revAdj) {
        5:  211:    visited[v] = true;
        5:  212:    component.push_back(v);
       19:  213:    for (int u : revAdj[v])
       14:  214:        if (!visited[u]) dfs2(u, visited, component, revAdj);
        5:  215:}
        -:  216:
        1:  217:std::vector<std::vector<int>> Graph::findSCCs() {
        1:  218:    std::stack<int> order;
        1:  219:    std::vector<bool> visited(numVertices, false);
        -:  220:
        6:  221:    for (int i = 0; i < numVertices; ++i)
        5:  222:        if (!visited[i]) dfs1(i, visited, order, adjList);
        -:  223:
        1:  224:    std::vector<std::vector<int>> revAdj(numVertices);
        6:  225:    for (int u = 0; u < numVertices; ++u)
       19:  226:        for (int v : adjList[u])
       14:  227:            revAdj[v].push_back(u);
        -:  228:
        1:  229:    std::fill(visited.begin(), visited.end(), false);
        1:  230:    std::vector<std::vector<int>> components;
        -:  231:
        6:  232:    while (!order.empty()) {
        5:  233:        int v = order.top(); order.pop();
        5:  234:        if (!visited[v]) {
        1:  235:            std::vector<int> component;
        1:  236:            dfs2(v, visited, component, revAdj);
        1:  237:            components.push_back(component);
        1:  238:        }
        -:  239:    }
        2:  240:    return components;
        1:  241:}
        -:  242:
        -:  243:// ---------- Max Flow (Edmonds-Karp) ----------
        4:  244:bool bfsFlow(const std::vector<std::vector<int>>& rGraph, int s, int t, std::vector<int>& parent) {
        4:  245:    int n = rGraph.size();
        4:  246:    std::vector<bool> visited(n, false);
        4:  247:    std::queue<int> q;
        -:  248:
        4:  249:    q.push(s);
        4:  250:    visited[s] = true;
        4:  251:    parent[s] = -1;
        -:  252:
       20:  253:    while (!q.empty()) {
       16:  254:        int u = q.front(); q.pop();
       96:  255:        for (int v = 0; v < n; ++v) {
       80:  256:            if (!visited[v] && rGraph[u][v] > 0) {
       12:  257:                q.push(v);
       12:  258:                parent[v] = u;
       12:  259:                visited[v] = true;
        -:  260:            }
        -:  261:        }
        -:  262:    }
        8:  263:    return visited[t];
        4:  264:}
        -:  265:
        1:  266:int Graph::maxFlow(int source, int sink) {
        2:  267:    std::vector<std::vector<int>> rGraph(numVertices, std::vector<int>(numVertices, 0));
        6:  268:    for (int u = 0; u < numVertices; ++u)
       19:  269:        for (int v : adjList[u])
       14:  270:            rGraph[u][v] += 1;
        -:  271:
        1:  272:    std::vector<int> parent(numVertices);
        1:  273:    int max_flow = 0;
        -:  274:
        4:  275:    while (bfsFlow(rGraph, source, sink, parent)) {
        3:  276:        int path_flow = INT_MAX;
        9:  277:        for (int v = sink; v != source; v = parent[v])
        6:  278:            path_flow = std::min(path_flow, rGraph[parent[v]][v]);
        -:  279:
        9:  280:        for (int v = sink; v != source; v = parent[v]) {
        6:  281:            int u = parent[v];
        6:  282:            rGraph[u][v] -= path_flow;
        6:  283:            rGraph[v][u] += path_flow;
        -:  284:        }
        3:  285:        max_flow += path_flow;
        -:  286:    }
        1:  287:    return max_flow;
        1:  288:}
