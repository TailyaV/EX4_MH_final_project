        -:    0:Source:pipling.cpp
        -:    1:#include "pipling.hpp"
        -:    2://Constractor
        4:    3:Pipling::Pipling() {}
        -:    4://Distractor
        4:    5:Pipling::~Pipling(){ stop(); }
        -:    6:
        -:    7:// Acuator 4 threads
        4:    8:void Pipling::start(){
        8:    9:    t1 = std::thread([this]{ stage1(); });
        8:   10:    t2 = std::thread([this]{ stage2(); });
        8:   11:    t3 = std::thread([this]{ stage3(); });
        8:   12:    t4 = std::thread([this]{ stage4(); });
        4:   13:}
        -:   14:
        -:   15:// Close safty all threads
        7:   16:void Pipling::stop(){
        7:   17:    q1.push(nullptr);
        7:   18:    if (t1.joinable()) t1.join();
        7:   19:    if (t2.joinable()) t2.join();
        7:   20:    if (t3.joinable()) t3.join();
        7:   21:    if (t4.joinable()) t4.join();
        7:   22:}
        -:   23:
        -:   24:// Receives and streams a graph for processing, push job to q1
        3:   25:void Pipling::submit(const Graph& g){
        -:   26:    // transfer graph to constractor
        3:   27:    auto job = std::make_shared<Job>(g); 
        3:   28:    q1.push(std::move(job));
        3:   29:}
        -:   30:
        -:   31:// Wait for final result
        3:   32:Pipling::Result Pipling::get(){
        -:   33:    for(;;){
        3:   34:        JobPtr j = qout.pop();     // Wait for results
        6:   35:        if (j) return j->result;
       3*:   36:    }
        -:   37:}
        -:   38:
        -:   39://Pop a Job from q1, compute MST weight, push to q2 graph and result (job) stop on sentinel.
        7:   40:void Pipling::stage1(){
        -:   41:    for(;;){
        -:   42:        // wait for next item from q1
        7:   43:        JobPtr j = q1.pop();
        -:   44:        // got sentinel: forward it to q2 and exit this stage
        7:   45:        if (!j){ q2.push(nullptr); break; }
        3:   46:        j->result.mst_weight = j->graph.mstWeight();
        3:   47:        q2.push(std::move(j));
       10:   48:    }
        4:   49:}
        -:   50:
        -:   51://Pop a Job from q2, count cliques, push to q3 graph and result (job) stop on sentinel.
        7:   52:void Pipling::stage2(){
        -:   53:    for(;;){
        7:   54:        JobPtr j = q2.pop();
        -:   55:        // got sentinel: forward it to q3 and exit this stage
        7:   56:        if (!j){ q3.push(nullptr); break; }
        3:   57:        j->result.num_cliques = j->graph.countCliques();
        3:   58:        q3.push(std::move(j));
       10:   59:    }
        4:   60:}
        -:   61:
        -:   62://Pop a Job from q3, find SCCs, push to q4 graph and result (job) stop on sentinel.
        7:   63:void Pipling::stage3(){
        -:   64:    for(;;){
        7:   65:        JobPtr j = q3.pop();
        -:   66:        // got sentinel: forward it to q4 and exit this stage
        7:   67:        if (!j){ q4.push(nullptr); break; }
        3:   68:        j->result.sccs = j->graph.findSCCs();
        3:   69:        q4.push(std::move(j));
       10:   70:    }
        4:   71:}
        -:   72:
        -:   73://Pop a Job from q4, computes max flow, push to qout graph and result (job) stop on sentinel.
        7:   74:void Pipling::stage4(){
        -:   75:    for(;;){
        7:   76:        JobPtr j = q4.pop();
        -:   77:        // got sentinel: forward it to qout and exit this stage
        7:   78:        if (!j){ qout.push(nullptr); break; }
        3:   79:        j->result.max_flow = j->graph.maxFlow(0, j->graph.getNumVertices() - 1);
        3:   80:        qout.push(std::move(j));
       10:   81:    }
        4:   82:}
